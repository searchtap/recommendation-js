{"version":3,"sources":["webpack://StRecommendationTracker/webpack/universalModuleDefinition","webpack://StRecommendationTracker/webpack/bootstrap","webpack://StRecommendationTracker/./src/StRecommendationTracker.ts","webpack://StRecommendationTracker/./node_modules/browser-cookies/src/browser-cookies.js","webpack://StRecommendationTracker/./src/util/JSONHelper.ts","webpack://StRecommendationTracker/./src/util/Logger.ts","webpack://StRecommendationTracker/./src/domain/EventTypes.ts","webpack://StRecommendationTracker/./node_modules/nanoid/index.browser.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","cookies","__importStar","JSONHelper_1","logger","EventTypes_1","__importDefault","nanoid","StRecommendationTracker","apiKey","trackAutoEvent","localUserCookieKey","cachedEvents","isPageLoaded","trackingServerBaseUrl","getUserId","waitForLoad","processPageLoad","_a","sent","startProcessingCachedEvents","canSendEventToServer","processCachedEvents","generateUserId","setUser","userId","localUserId","saveLocalUserIdCookieToBrowser","set","path","expires","setGlobalProps","properties","JSONHelper","isValidJson","error","globalEventProperties","track","eventName","eventData","trackingData","timeStamp","Date","valueOf","assign","sendEventToServer","push","length","shift","default","pageLoad","title","document","href","window","location","origin","pathname","event","img","createElement","src","encodeURIComponent","JSON","stringify","style","display","body","appendChild","defaults","options","opts","domain","undefined","secure","httponly","samesite","expDate","getTime","cookie","replace","toUTCString","split","pop","separatorIndex","indexOf","decodeURIComponent","slice","erase","all","json","constructor","console","EventTypes","crypto","msCrypto","size","id","bytes","getRandomValues","Uint8Array"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StRecommendationTracker\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StRecommendationTracker\"] = factory();\n\telse\n\t\troot[\"StRecommendationTracker\"] = factory();\n})(typeof self !== \"undefined\" ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import * as cookies from \"browser-cookies\";\nimport {JSONHelper} from \"./util/JSONHelper\";\nimport {ITrackingData} from \"./domain/ITrackingData\";\nimport * as logger from \"./util/Logger\";\nimport EventTypes from \"./domain/EventTypes\";\n\nconst nanoid = require('nanoid')\n\nexport = class StRecommendationTracker {\n  private localUserId: string;\n  private localUserCookieKey = \"uId\";\n  private globalEventProperties: { [prop: string]: any };\n  private cachedEvents: ITrackingData[] = [];\n  private isPageLoaded: boolean = false;\n  private trackingServerBaseUrl: string = process.env.ST_TRACKING_SERVER;\n\n  constructor(private apiKey: string, private trackAutoEvent: boolean = true) {\n    this.getUserId();\n    this.waitForLoad();\n  }\n\n\n  private async waitForLoad() {\n    this.isPageLoaded = true;\n    if (this.trackAutoEvent)\n      await this.processPageLoad();\n    this.startProcessingCachedEvents();\n\n  }\n\n  private startProcessingCachedEvents() {\n    if (this.canSendEventToServer()) {\n      this.processCachedEvents();\n    }\n  }\n\n\n  /***\n   * request new user id from server\n   */\n  private async generateUserId(): Promise<string | null> {\n    return nanoid();\n\n  }\n\n\n  public setUser(userId: string) {\n    this.localUserId = userId;\n    this.saveLocalUserIdCookieToBrowser(this.localUserId);\n\n    return this;\n  }\n\n  /***\n   * get local user id if exists else create new\n   */\n  private async getUserId() {\n\n    if (!this.localUserId) {\n      this.localUserId = cookies.get(this.localUserCookieKey);\n      if (!this.localUserId) {\n        let userId = await this.generateUserId();\n        if (userId) {\n          this.localUserId = userId;\n          this.saveLocalUserIdCookieToBrowser(this.localUserId);\n        }\n      } else {\n        //re-initialize cookie\n        this.saveLocalUserIdCookieToBrowser(this.localUserId);\n      }\n    }\n  }\n\n  /***\n   * save local user id cookie to browser\n   * @param userId\n   */\n  private saveLocalUserIdCookieToBrowser(userId: string) {\n    cookies.set(this.localUserCookieKey, userId, {\n      path: \"/\",\n      expires: 367 * 2\n    });\n    this.startProcessingCachedEvents();\n  }\n\n\n  /***\n   * assign global properties to be send in each event request\n   * @param properties\n   */\n  public setGlobalProps(properties: { [prop: string]: any }) {\n    if (!JSONHelper.isValidJson(properties))\n      logger.error(\"Invalid data provided for global Event properties\");\n    this.globalEventProperties = properties;\n  }\n\n  /***\n   * send event to server\n   * @param eventName\n   * @param eventData\n   */\n  public async track(eventName: string, eventData: { [prop: string]: any }) {\n    let trackingData: ITrackingData = {\n      eventName: eventName,\n      eventData: eventData,\n      timeStamp: new Date().valueOf()\n    };\n    //give preference to event properties upon global event properties\n    trackingData.eventData = Object.assign({}, this.globalEventProperties, trackingData.eventData);\n    if (this.canSendEventToServer())\n      await this.sendEventToServer(trackingData);\n    else {\n      this.cachedEvents.push(trackingData);\n    }\n\n  }\n\n  private canSendEventToServer(): boolean {\n    return this.isPageLoaded;\n  }\n\n\n  private async processCachedEvents() {\n    while (this.cachedEvents.length) {\n      await this.sendEventToServer(this.cachedEvents.shift())\n    }\n  }\n\n  private processPageLoad() {\n    return this.track(EventTypes.pageLoad, {\n      title: document.title,\n      href: window.location.href,\n      origin: window.location.origin,\n      pathname: window.location.pathname\n    });\n  }\n\n  private async sendEventToServer(event: ITrackingData) {\n    const img = document.createElement('img');\n    img.src = `${this.trackingServerBaseUrl}/e?key=${this.apiKey}&${this.localUserCookieKey}=${this.localUserId}&data=${encodeURIComponent(JSON.stringify(event))}`;\n    img.style.display = 'none';\n    document.body.appendChild(img);\n  }\n\n}\n","exports.defaults = {};\r\n\r\nexports.set = function(name, value, options) {\r\n  // Retrieve options and defaults\r\n  var opts = options || {};\r\n  var defaults = exports.defaults;\r\n\r\n  // Apply default value for unspecified options\r\n  var expires  = opts.expires  || defaults.expires;\r\n  var domain   = opts.domain   || defaults.domain;\r\n  var path     = opts.path     !== undefined ? opts.path     : (defaults.path !== undefined ? defaults.path : '/');\r\n  var secure   = opts.secure   !== undefined ? opts.secure   : defaults.secure;\r\n  var httponly = opts.httponly !== undefined ? opts.httponly : defaults.httponly;\r\n  var samesite = opts.samesite !== undefined ? opts.samesite : defaults.samesite;\r\n\r\n  // Determine cookie expiration date\r\n  // If succesful the result will be a valid Date, otherwise it will be an invalid Date or false(ish)\r\n  var expDate = expires ? new Date(\r\n      // in case expires is an integer, it should specify the number of days till the cookie expires\r\n      typeof expires === 'number' ? new Date().getTime() + (expires * 864e5) :\r\n      // else expires should be either a Date object or in a format recognized by Date.parse()\r\n      expires\r\n  ) : 0;\r\n\r\n  // Set cookie\r\n  document.cookie = name.replace(/[^+#$&^`|]/g, encodeURIComponent)                // Encode cookie name\r\n  .replace('(', '%28')\r\n  .replace(')', '%29') +\r\n  '=' + value.replace(/[^+#$&/:<-\\[\\]-}]/g, encodeURIComponent) +                  // Encode cookie value (RFC6265)\r\n  (expDate && expDate.getTime() >= 0 ? ';expires=' + expDate.toUTCString() : '') + // Add expiration date\r\n  (domain   ? ';domain=' + domain     : '') +                                      // Add domain\r\n  (path     ? ';path='   + path       : '') +                                      // Add path\r\n  (secure   ? ';secure'               : '') +                                      // Add secure option\r\n  (httponly ? ';httponly'             : '') +                                      // Add httponly option\r\n  (samesite ? ';samesite=' + samesite : '');                                       // Add samesite option\r\n};\r\n\r\nexports.get = function(name) {\r\n  var cookies = document.cookie.split(';');\r\n  \r\n  // Iterate all cookies\r\n  while(cookies.length) {\r\n    var cookie = cookies.pop();\r\n\r\n    // Determine separator index (\"name=value\")\r\n    var separatorIndex = cookie.indexOf('=');\r\n\r\n    // IE<11 emits the equal sign when the cookie value is empty\r\n    separatorIndex = separatorIndex < 0 ? cookie.length : separatorIndex;\r\n\r\n    var cookie_name = decodeURIComponent(cookie.slice(0, separatorIndex).replace(/^\\s+/, ''));\r\n\r\n    // Return cookie value if the name matches\r\n    if (cookie_name === name) {\r\n      return decodeURIComponent(cookie.slice(separatorIndex + 1));\r\n    }\r\n  }\r\n\r\n  // Return `null` as the cookie was not found\r\n  return null;\r\n};\r\n\r\nexports.erase = function(name, options) {\r\n  exports.set(name, '', {\r\n    expires:  -1,\r\n    domain:   options && options.domain,\r\n    path:     options && options.path,\r\n    secure:   0,\r\n    httponly: 0}\r\n  );\r\n};\r\n\r\nexports.all = function() {\r\n  var all = {};\r\n  var cookies = document.cookie.split(';');\r\n\r\n  // Iterate all cookies\r\n  while(cookies.length) {\r\n    var cookie = cookies.pop();\r\n\r\n    // Determine separator index (\"name=value\")\r\n    var separatorIndex = cookie.indexOf('=');\r\n\r\n    // IE<11 emits the equal sign when the cookie value is empty\r\n    separatorIndex = separatorIndex < 0 ? cookie.length : separatorIndex;\r\n\r\n    // add the cookie name and value to the `all` object\r\n    var cookie_name = decodeURIComponent(cookie.slice(0, separatorIndex).replace(/^\\s+/, ''));\r\n    all[cookie_name] = decodeURIComponent(cookie.slice(separatorIndex + 1));\r\n  }\r\n\r\n  return all;\r\n};\r\n","export class JSONHelper {\n  static isValidJson(json) {\n    try {\n      return json.constructor === Object;\n    }\n    catch (error) {\n      return false;\n    }\n  }\n}","let logger: any = {};\nif (process.env.RUN_ENV === \"production\") {\n  logger = {\n    error: function (...params) {\n    },\n    log: function (...params) {\n    },\n    info: function (...params) {\n    }\n  }\n} else {\n  logger = console;\n}\n\nexport = logger;","export default class EventTypes {\n  static pageLoad='page-load';\n}","if (process.env.NODE_ENV !== 'production') {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n      'If you don’t need unpredictable IDs, you can use `nanoid/non-secure`. ' +\n      'For secure ID install `expo-random` locally and use `nanoid/async`.'\n    )\n  }\n  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n      'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nvar crypto = self.crypto || self.msCrypto\n\n/*\n * This alphabet uses a-z A-Z 0-9 _- symbols.\n * Symbols order was changed for better gzip compression.\n */\nvar url = 'QLUint8ARdomValuesObj0h6345-79BCrypgJzHKTNYDSMkXPZ_FfG1WcqvwxEI2'\n\nmodule.exports = function (size) {\n  size = size || 21\n  var id = ''\n  var bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    id += url[bytes[size] & 63]\n  }\n  return id\n}\n"],"sourceRoot":""}